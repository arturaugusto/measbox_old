<!DOCTYPE html>
<html lang="en">
<head>
    <title>dc.js - Box-Plot Example</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="/assets/dc.css?body=1"/>
</head>
<body>

<div id="box-test"></div>

<script data-turbolinks-track="true" src="/assets/d3.min.js?body=1"></script>
<script data-turbolinks-track="true" src="/assets/crossfilter.min.js?body=1"></script>
<script data-turbolinks-track="true" src="/assets/dc.js?body=1"></script>



<script type="text/javascript">

  // Inspired by http://informationandvisualization.de/blog/box-plot
  d3.box = function () {
      var width = 1,
          height = 1,
          duration = 0,
          domain = null,
          value = Number,
          whiskers = boxWhiskers,
          quartiles = boxQuartiles,
          tickFormat = null;

      // For each small multipleâ€¦
      function box(g) {
          g.each(function (d, i) {
              d = d.map(value).sort(d3.ascending);
              var g = d3.select(this),
                  n = d.length,
                  min = d[0],
                  max = d[n - 1];

              var quartileData = d.quartiles = quartiles(d);

              // Compute whiskers. Must return exactly 2 elements, or null.
              var whiskerIndices = whiskers && whiskers.call(this, d, i),
                  whiskerData = whiskerIndices && whiskerIndices.map(function (i) { return d[i]; });

              // Compute the new x-scale.
              var x1 = d3.scale.linear()
                  .domain(domain && domain.call(this, d, i) || [min, max])
                  .range([height, 0]);

              // Retrieve the old x-scale, if this is an update.
              var x0 = this.__chart__ || d3.scale.linear()
                  .domain([0, Infinity])
                  .range(x1.range());

              // Stash the new scale.
              this.__chart__ = x1;

              // Note: the box, median, and box tick elements are fixed in number,
              // so we only have to handle enter and update. In contrast, the outliers
              // and other elements are variable, so we need to exit them! Variable
              // elements also fade in and out.

              // Update center line: the vertical line spanning the whiskers.
              var center = g.selectAll('line.center')
                  .data(whiskerData ? [whiskerData] : []);

              center.enter().insert('line', 'rect')
                  .attr('class', 'center')
                  .attr('x1', width / 2)
                  .attr('y1', function (d) { return x0(d[0]); })
                  .attr('x2', width / 2)
                  .attr('y2', function (d) { return x0(d[1]); })
                  .style('opacity', 1e-6)
                .transition()
                  .duration(duration)
                  .style('opacity', 1)
                  .attr('y1', function (d) { return x1(d[0]); })
                  .attr('y2', function (d) { return x1(d[1]); });

              center.transition()
                  .duration(duration)
                  .style('opacity', 1)
                  .attr('y1', function (d) { return x1(d[0]); })
                  .attr('y2', function (d) { return x1(d[1]); });

              center.exit().transition()
                  .duration(duration)
                  .style('opacity', 1e-6)
                  .attr('y1', function (d) { return x1(d[0]); })
                  .attr('y2', function (d) { return x1(d[1]); })
                  .remove();

              // Update median line.

              var medianLine = g.selectAll('line.median')
                  .data([d[1]]);

              medianLine.enter().append('line')
                  .attr('class', 'median')
                  .attr('x1', 0)
                  .attr('y1', x0)
                  .attr('x2', width)
                  .attr('y2', x0)
                  .transition()
                  .duration(duration)
                  .attr('y1', x1)
                  .attr('y2', x1);

              medianLine.transition()
                  .duration(duration)
                  .attr('y1', x1)
                  .attr('y2', x1);

              // Update whiskers.
              var whisker = g.selectAll('line.whisker')
                  .data(whiskerData || []);

              whisker.enter().insert('line', 'circle, text')
                  .attr('class', 'whisker')
                  .attr('x1', 0)
                  .attr('y1', x0)
                  .attr('x2', width)
                  .attr('y2', x0)
                  .style('opacity', 1e-6)
                .transition()
                  .duration(duration)
                  .attr('y1', x1)
                  .attr('y2', x1)
                  .style('opacity', 1);

              whisker.transition()
                  .duration(duration)
                  .attr('y1', x1)
                  .attr('y2', x1)
                  .style('opacity', 1);

              whisker.exit().transition()
                  .duration(duration)
                  .attr('y1', x1)
                  .attr('y2', x1)
                  .style('opacity', 1e-6)
                  .remove();

              // Compute the tick format.
              var format = tickFormat || x1.tickFormat(8);

              // Update box ticks.
              var boxTick = g.selectAll('text.box')
                  .data(quartileData);
              
              boxTick.enter().append('text')
                  .attr('class', 'box')
                  .attr('dy', '.3em')
                  .attr('dx', -6)
                  .attr('x', 0)
                  .attr('y', x0)
                  .attr('text-anchor', function (d, i) { return i & 1 ? 'start' : 'end'; })
                  .text(format)
                  .transition()
                  .duration(duration)
                  .attr('y', x1);
              
              boxTick.transition()
                  .duration(duration)
                  .text(format)
                  .attr('y', x1);

              // Update whisker ticks. These are handled separately from the box
              // ticks because they may or may not exist, and we want don't want
              // to join box ticks pre-transition with whisker ticks post-.
              var whiskerTick = g.selectAll('text.whisker')
                  .data(whiskerData || []);

              whiskerTick.enter().append('text')
                  .attr('class', 'whisker')
                  .attr('dy', '.3em')
                  .attr('dx', 6)
                  .attr('x', width)
                  .attr('y', x0)
                  .text(format)
                  .style('opacity', 1e-6)
                  .transition()
                  .duration(duration)
                  .attr('y', x1)
                  .style('opacity', 1);

              whiskerTick.transition()
                  .duration(duration)
                  .text(format)
                  .attr('y', x1)
                  .style('opacity', 1);

              whiskerTick.exit().transition()
                  .duration(duration)
                  .attr('y', x1)
                  .style('opacity', 1e-6)
                  .remove();
          });
          d3.timer.flush();
      }

      box.width = function (x) {
          if (!arguments.length) {
              return width;
          }
          width = x;
          return box;
      };

      box.height = function (x) {
          if (!arguments.length) {
              return height;
          }
          height = x;
          return box;
      };

      box.tickFormat = function (x) {
          if (!arguments.length) {
              return tickFormat;
          }
          tickFormat = x;
          return box;
      };

      box.duration = function (x) {
          if (!arguments.length) {
              return duration;
          }
          duration = x;
          return box;
      };

      box.domain = function (x) {
          if (!arguments.length) {
              return domain;
          }
          domain = x === null ? x : d3.functor(x);
          return box;
      };

      box.value = function (x) {
          if (!arguments.length) {
              return value;
          }
          value = x;
          return box;
      };

      box.whiskers = function (x) {
          if (!arguments.length) {
              return whiskers;
          }
          whiskers = x;
          return box;
      };

      box.quartiles = function (x) {
          if (!arguments.length) {
              return quartiles;
          }
          quartiles = x;
          return box;
      };

      return box;
  };

  function boxWhiskers(d) {
      return [0, d.length - 1];
  }

  function boxQuartiles(d) {
      return [
          d[1]
      ];
  }

///////////////////////////////////////////////

dc.boxPlotHack = function (parent, chartGroup) {
    var _chart = dc.coordinateGridMixin({});

    var _whiskers = function(){return [0, 2]}; // Index of uncertanty limits


    var _box = d3.box();
    var _tickFormat = null;

    var _boxWidth = function (innerChartWidth, xUnits) {
        if (_chart.isOrdinal()) {
            return _chart.x().rangeBand();
        } else {
            return innerChartWidth / (1 + _chart.boxPadding()) / xUnits;
        }
    };

    // default padding to handle min/max whisker text
    _chart.yAxisPadding(12);

    // default to ordinal
    _chart.x(d3.scale.ordinal());
    _chart.xUnits(dc.units.ordinal);

    // valueAccessor should return an array of values that can be coerced into numbers
    // or if data is overloaded for a static array of arrays, it should be `Number`.
    // Empty arrays are not included.
    _chart.data(function (group) {
        return group.all().map(function (d) {
            d.map = function (accessor) { return accessor.call(d, d); };
            return d;
        }).filter(function (d) {
            var values = _chart.valueAccessor()(d);
            return values.length !== 0;
        });
    });

    /**
    #### .boxPadding([padding])
    Get or set the spacing between boxes as a fraction of box size. Valid values are within 0-1.
    See the [d3 docs](https://github.com/mbostock/d3/wiki/Ordinal-Scales#wiki-ordinal_rangeBands)
    for a visual description of how the padding is applied.
    Default: 0.8
    **/
    _chart.boxPadding = _chart._rangeBandPadding;
    _chart.boxPadding(0.8);

    /**
    #### .outerPadding([padding])
    Get or set the outer padding on an ordinal box chart. This setting has no effect on non-ordinal charts
    or on charts with a custom `.boxWidth`. Will pad the width by `padding * barWidth` on each side of the chart.
    Default: 0.5
    **/
    _chart.outerPadding = _chart._outerRangeBandPadding;
    _chart.outerPadding(0.5);

    /**
     #### .boxWidth(width || function(innerChartWidth, xUnits) { ... })
     Get or set the numerical width of the boxplot box. The width may also be a function taking as
     parameters the chart width excluding the right and left margins, as well as the number of x
     units.
     **/
    _chart.boxWidth = function (_) {
        if (!arguments.length) {
            return _boxWidth;
        }
        _boxWidth = d3.functor(_);
        return _chart;
    };

    var boxTransform = function (d, i) {
        var xOffset = _chart.x()(_chart.keyAccessor()(d, i));
        return 'translate(' + xOffset + ', 0)';
    };

    _chart._preprocessData = function () {
        if (_chart.elasticX()) {
            _chart.x().domain([]);
        }
    };

    _chart.plotData = function () {
        var _calculatedBoxWidth = _boxWidth(_chart.effectiveWidth(), _chart.xUnitCount());

        _box.whiskers(_whiskers)
            .width(_calculatedBoxWidth)
            .height(_chart.effectiveHeight())
            .value(_chart.valueAccessor())
            .domain(_chart.y().domain())
            .duration(_chart.transitionDuration())
            .tickFormat(_tickFormat);

        
        var boxesG = _chart.chartBodyG().selectAll('g.box').data(_chart.data(), function (d) { return d.key; });

        renderBoxes(boxesG);
        updateBoxes(boxesG);
        removeBoxes(boxesG);
    };

    function renderBoxes(boxesG) {
        var boxesGEnter = boxesG.enter().append('g');


        boxesGEnter
            .attr('class', 'box')
            .attr('transform', boxTransform)
            .call(_box);
    }

    function updateBoxes(boxesG) {
      
        dc.transition(boxesG, _chart.transitionDuration())
        
            .attr('transform', boxTransform)
            .call(_box)
            .each(function () {
                d3.select(this).select('rect.box')
                .attr('fill', _chart.getColor)
            });

    }

    function removeBoxes(boxesG) {
        boxesG.exit().remove().call(_box);
    }

    _chart.yAxisMin = function () {
        var min = d3.min(_chart.data(), function (e) {
            return d3.min(_chart.valueAccessor()(e));
        });
        return dc.utils.subtract(min, _chart.yAxisPadding());
    };

    _chart.yAxisMax = function () {
        var max = d3.max(_chart.data(), function (e) {
            return d3.max(_chart.valueAccessor()(e));
        });
        return dc.utils.add(max, _chart.yAxisPadding());
    };

    _chart.tickFormat = function (x) {
        if (!arguments.length) {
            return _tickFormat;
        }
        _tickFormat = x;
        return _chart;
    };
    _chart.tickFormat(d3.format('.2e'));

    return _chart.anchor(parent, chartGroup);
};

//////////////////////////////////////////////////////////////

//chart.data()[0].value[0] = 780;chart.redraw() to update

var chart = dc.boxPlotHack("#box-test");
var experiments = [{"Expt": 1, "Run": 1, "Speed": 820}, {"Expt": 1, "Run": 1, "Speed": 740}, {"Expt": 1, "Run": 1, "Speed": 900}]
  console.log(experiments)
  experiments.forEach(function(x) {
    x.Speed = +x.Speed;
  });

  var ndx                 = crossfilter(experiments),
      runDimension        = ndx.dimension(function(d) {return +d.Run;}),
      runGroup            = runDimension.group(),
      experimentDimension = ndx.dimension(function(d) {return "exp-" + d.Expt;}),
      speedArrayGroup     = experimentDimension.group().reduce(
        function(p,v) {
          p.push(v.Speed);
          return p;
        },
        function(p,v) {
          p.splice(p.indexOf(v.Speed), 1);
          return p;
        },
        function() {
          return [];
        }
      );
  chart
    .width(768)
    .height(480)
    .margins({top: 10, right: 50, bottom: 30, left: 50})
    .dimension(experimentDimension)
    .group(speedArrayGroup)
    .elasticY(true)
    .elasticX(true)
    .on('renderlet', function(chart) {

      var left_y = 880, right_y = 880; // use real statistics here!

      
      
      var extra_data = [{x: 0, y: chart.y()(left_y)}, {x: 768, y: chart.y()(right_y)}];
      var line = d3.svg.line()
          .x(function(d) { return d.x; })
          .y(function(d) { return d.y; })
          .interpolate('linear');
      var path = chart.select('g.chart-body').selectAll('path.extra').data([extra_data]);
      path.enter().append('path').attr('class', 'extra').attr('stroke', 'red');
      path.attr('d', line);
      

    })
  chart.render()

//  dc.renderAll();
// Line
/*
/*
/*
  var i=0;
  setInterval(function() {
    runDimension.filterAll();
    runDimension.filter([i++,21]);
    dc.renderAll();
  }, 2000);
*/

</script>

</body>
</html>
